---
title: "chp2"
author: "Vasco Braz√£o"
date: "11/14/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages
```{r packages}
library(tidyverse)
```

## 2E1

*The probability of rain on Monday* could be restated as *the probability of rain, given that it is Monday*: Pr(Rain|Monday), answer (2)

## 2E2

Answer (3).

## 2E3 

Answer (1).

## 2E4

The statement can be interpreted in many ways. For instance, we could interpret it to mean that the 70% globe surface is colored blue, and that any of the points on the surface is equally likely to land under your right index finger.

## 2M1

Computing and plotting the grid approximate posterior distribution for different sets of observations. I will use 20 bins for this, and do my best to use tidyverse. Let's see how it goes.

(1) W, W, W
(2) W, W, W, L
(3) L, W, W, L, W, W, W

```{r 2m1.grid}
p_grid <- tibble(
  # define the grid
  probs = seq(from = 0, to = 1, length.out = 20),
  # define the prior
  prior = 1
)
```

Above I defined the grid. Now I would need to compute the likelihood, for each probability, of the data.Then multiply the likelihood with the prior, and then standardize. 

```{r 2m1.posteriors}
p_grid <- p_grid %>%
  mutate(
    # likelihood for (1), (2), then (3)
    first = dbinom(3, size = 3, prob = probs),
    secon = dbinom(3, size = 4, prob = probs),
    third = dbinom(5, size = 7, prob = probs),
    
    # posteriors
    first_uns_pos = first * prior,
    secon_uns_pos = secon * prior,
    third_uns_pos = third * prior,
    
    # standardizing
    first_pos = first_uns_pos / sum(first_uns_pos),
    secon_pos = secon_uns_pos / sum(secon_uns_pos),
    third_pos = third_uns_pos / sum(third_uns_pos)
  )
```

Now plots!

```{r 2m1.plots}
# graph for (1)
p_grid %>%
  ggplot(aes(x = probs, y = first_pos)) +
  geom_point() +
  geom_line() +
  labs(
    title = "Grid approx. posterior distribution for probability of W",
    subtitle = "Data = W, W, W",
    x = "Probability of W",
    y = "Posterior"
  ) +
  theme_bw()

# graph for (2)
p_grid %>%
  ggplot(aes(x = probs, y = secon_pos)) +
  geom_point() +
  geom_line() +
  labs(
    title = "Grid approx. posterior distribution for probability of W",
    subtitle = "Data = W, W, W, L",
    x = "Probability of W",
    y = "Posterior"
  ) +
  theme_bw()

# graph for (3)
p_grid %>%
  ggplot(aes(x = probs, y = third_pos)) +
  geom_point() +
  geom_line() +
  labs(
    title = "Grid approx. posterior distribution for probability of W",
    subtitle = "Data = L, W, W, L, W, W, W",
    x = "Probability of W",
    y = "Posterior"
  ) +
  theme_bw()
```

Yuhu!

Some thoughts: lots of repetitions in my code. If I try to improve it later, I might:

* Create actual variables for the data, and then a function that extracts the correct values to place in dbinom() 
* Create a function (or loop??) to generate the plots without repeating myself so much.

## 2M2

Now the prior should be 0 for p<0.5 (we do know more that half the globe is covered in water, after all), and "a positive constant" for p >= 0.5. Perhaps this positive constant should be 2, since the prior needs to integrate to 1? (Update: thinking through it, perhaps any constant would work, since we standardize anyway? Might try to test it later, but I'll leave the original for now.)

So we can just copy the code above and change the prior, methinks.

```{r 2m2.grid}
p_grid <- tibble(
  # define the grid
  probs = seq(from = 0, to = 1, length.out = 20),
  # define the prior
  prior = ifelse(
    probs < .5, 0, 2
  )
)
```

Above I defined the grid. Now I would need to compute the likelihood, for each probability, of the data.Then multiply the likelihood with the prior, and then standardize. 

```{r 2m2.posteriors}
p_grid <- p_grid %>%
  mutate(
    # likelihood for (1), (2), then (3)
    first = dbinom(3, size = 3, prob = probs),
    secon = dbinom(3, size = 4, prob = probs),
    third = dbinom(5, size = 7, prob = probs),
    
    # posteriors
    first_uns_pos = first * prior,
    secon_uns_pos = secon * prior,
    third_uns_pos = third * prior,
    
    # standardizing
    first_pos = first_uns_pos / sum(first_uns_pos),
    secon_pos = secon_uns_pos / sum(secon_uns_pos),
    third_pos = third_uns_pos / sum(third_uns_pos)
  )
```

Thus, the plots become:

```{r 2m2.plots}
# graph for (1)
p_grid %>%
  ggplot(aes(x = probs, y = first_pos)) +
  geom_point() +
  geom_line() +
  labs(
    title = "Grid approx. posterior distribution for probability of W",
    subtitle = "Data = W, W, W",
    x = "Probability of W",
    y = "Posterior"
  ) +
  theme_bw()

# graph for (2)
p_grid %>%
  ggplot(aes(x = probs, y = secon_pos)) +
  geom_point() +
  geom_line() +
  labs(
    title = "Grid approx. posterior distribution for probability of W",
    subtitle = "Data = W, W, W, L",
    x = "Probability of W",
    y = "Posterior"
  ) +
  theme_bw()

# graph for (3)
p_grid %>%
  ggplot(aes(x = probs, y = third_pos)) +
  geom_point() +
  geom_line() +
  labs(
    title = "Grid approx. posterior distribution for probability of W",
    subtitle = "Data = L, W, W, L, W, W, W",
    x = "Probability of W",
    y = "Posterior"
  ) +
  theme_bw()
```

## 2M3

So, Bayes' rule will probably be handy.

P(Earth|Land) = P(Land|Earth) * P(Earth) / P(Land)

But in this case what is P(Land)? I'd say it's the total proportion of land in the two planets? So, in this experiment in general, what is the probability that you will get "land"? That would be P(Land|Earth) * P(Earth) + P(Land|Mars) * P(Mars), an expected value of sorts... 

Substituting:
P(Earth|Land) = P(Land|Earth) * P(Earth) / P(Land|Earth) * P(Earth) + P(Land|Mars) * P(Mars)

Ok, now in code.

```{r 2m3}
p_earth <- .5
p_mars <- .5
p_land_given_earth <- .3
p_land_given_mars <- 1

p_earth_given_land <- (p_land_given_earth * p_earth) / (p_land_given_earth * p_earth + p_land_given_mars * p_mars)

print(p_earth_given_land)
```

Note to self: learn to make the equations pretty. 

## 2M4

```{r 2m4}
cards <- c(
  first = 2,
  secon = 1,
  third = 0
)

black_given_black <- cards[["first"]] / sum(cards)

print(black_given_black)
```
## 2M5

```{r 2m5}
cards <- c(
  first = 2,
  secon = 1,
  third = 0,
  fourt = 2
)

black_given_black <- (cards[["first"]] + cards[["fourt"]]) / sum(cards)

print(black_given_black)
```

## 2M6

```{r 2m6}
cards <- tibble(
  card = c(
    first = 2,
    secon = 1,
    third = 0
  ),
  ways = c(
    1,
    2,
    3
  ),
  update = card*ways
)

black_given_black <- cards$update[[1]]/sum(cards$update)

print(black_given_black)
```
